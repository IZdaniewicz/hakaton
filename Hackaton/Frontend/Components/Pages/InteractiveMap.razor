@page "/interaktywna-mapa"

<h3>Interaktywna mapa szpitala</h3>

<select @bind="selectedImage">
    <option value="">Wybierz obrazek</option>
    @foreach (var image in availableImages)
    {
        <option value="@image">@image</option>
    }
</select>

@if (!string.IsNullOrEmpty(selectedImage))
{
    <div id="mapContainer" class="map-container"
         @onclick="AddPoint"
         @onmousemove="UpdateCurrentPosition"
         @onmouseleave="ClearCurrentPosition">
        <img @ref="imageRef" src="images/@selectedImage" alt="Plan szpitala" class="map-image" />
        <svg class="route-overlay">
            @for (int i = 0; i < points.Count - 1; i++)
            {
                <line x1="@points[i].X" y1="@points[i].Y" x2="@points[i + 1].X" y2="@points[i + 1].Y"
                      stroke="red" stroke-width="4" />
            }
            @if (currentMousePosition != null && points.Count > 0)
            {
                <line x1="@points.Last().X" y1="@points.Last().Y" 
                      x2="@currentMousePosition.X" y2="@currentMousePosition.Y"
                      stroke="red" stroke-dasharray="5,5" stroke-width="2" />
            }
            @foreach (var point in points)
            {
                <circle cx="@point.X" cy="@point.Y" r="5" fill="red" />
            }
        </svg>
    </div>
    <button class="btn btn-sm btn-secondary mt-2" @onclick="ResetRoute">Resetuj trasę</button>
    <button class="btn btn-sm btn-primary mt-2" @onclick="SaveImage">Zapisz obraz</button>
}
else
{
    <p>Nie wybrano obrazka. Wybierz obrazek z listy.</p>
}

@code {
    private List<string> availableImages = new() { "hospital-map.png" };
    private string selectedImage = "";
    private ElementReference imageRef;
    private List<Point> points = new();
    private Point? currentMousePosition = null;

    private async Task AddPoint(MouseEventArgs e)
    {
        var rect = await JS.InvokeAsync<BoundingClientRect>("getBoundingClientRect", imageRef);
        double x = e.ClientX - rect.Left;
        double y = e.ClientY - rect.Top;
        points.Add(new Point(x, y));
        currentMousePosition = null;
        StateHasChanged();
    }

    private async Task UpdateCurrentPosition(MouseEventArgs e)
    {
        var rect = await JS.InvokeAsync<BoundingClientRect>("getBoundingClientRect", imageRef);
        double x = e.ClientX - rect.Left;
        double y = e.ClientY - rect.Top;
        currentMousePosition = new Point(x, y);
        StateHasChanged();
    }

    private void ClearCurrentPosition(MouseEventArgs e)
    {
        currentMousePosition = null;
        StateHasChanged();
    }

    private void ResetRoute()
    {
        points.Clear();
        currentMousePosition = null;
        StateHasChanged();
    }

    private async Task SaveImage()
    {
        var pointData = points.Select(p => new { x = p.X, y = p.Y }).ToArray();
        await JS.InvokeVoidAsync("saveMapImage", "mapContainer", pointData);
    }

    public class Point
    {
        public double X { get; set; }
        public double Y { get; set; }
        public Point(double x, double y)
        {
            X = x;
            Y = y;
        }
    }

    public class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    [Inject] private IJSRuntime JS { get; set; }
}
