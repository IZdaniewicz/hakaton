@page "/map"
@inject IJSRuntime JS

<h3>Mapa piętra @SvgNum</h3>

<div style="margin-bottom: 10px;">
    <label for="floorSelect" style="margin-right: 8px;">Wybierz piętro:</label>
    <select id="floorSelect" class="form-select" style="width: 120px; display: inline-block;"
            @onchange="FloorSelected">
        <option value="0">0</option>
        <option value="1">1</option>
    </select>
</div>

<!-- Dynamicznie ładowany SVG -->
@if (SvgNum == 0)
{
    <div style="width: 100%; height: 600px; overflow: auto; border: 1px solid #ccc;">
        <object @key="SvgPath"
                id="svgObject"
                type="image/svg+xml"
                data="@SvgPath"
                style="min-width: 1000px; min-height: 800px;">
        </object>
    </div>

}
else
{
    <div style="width: 100%; height: 600px; overflow: auto; border: 1px solid #ccc;">
        <object @key="SvgPath"
                id="svgObject"
                type="image/svg+xml"
                data="@SvgPath"
                style="min-width: 1000px; min-height: 800px;">
        </object>
    </div>

}

<Core.Components.Dialogs.TemplatedDialog IsHidden="string.IsNullOrEmpty(ImagePath)" OnClose="CloseDialog">
    <div style="position: relative; width: 100%; height: 100%;">
        <a-scene embedded style="width: 100%; height: 100%;">
            <a-sky src="@ImagePath"></a-sky>
        </a-scene>

        <div class="button-overlay">
            @if (PreviousImage is not null)
            {
                    <button @onclick="() => SwitchDialog(false)" class="nav-button btn-back">←</button>
            }
            @if (NextImage is not null)
            {
                    <button @onclick="() => SwitchDialog(true)" class="nav-button btn-next">→</button>
            }
        </div>
    </div>
</Core.Components.Dialogs.TemplatedDialog>

<style>
    :root {
        --btn-size: 60px;
        --btn-bg-color: rgba(255, 255, 255, 0.7);
        --btn-bg-hover: rgba(255, 255, 255, 1);
        --btn-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        --btn-font-size: 24px;
        --btn-font-weight: 700;
        --btn-radius: 50%;
        --btn-color: #000;
        --btn-transition: all 0.3s ease;
        --overlay-padding: 1rem;
        --overlay-align: center;
        --overlay-justify: space-between;
    }

    .button-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: var(--overlay-align);
        justify-content: var(--overlay-justify);
        pointer-events: none;
        padding: var(--overlay-padding);
        box-sizing: border-box;
    }

    .nav-button {
        width: var(--btn-size);
        height: var(--btn-size);
        border-radius: var(--btn-radius);
        border: none;
        background-color: var(--btn-bg-color);
        color: var(--btn-color);
        font-size: var(--btn-font-size);
        font-weight: var(--btn-font-weight);
        box-shadow: var(--btn-shadow);
        cursor: pointer;
        transition: var(--btn-transition);
        pointer-events: auto;
    }

    .nav-button:hover {
        background-color: var(--btn-bg-hover);
        transform: scale(1.1);
    }

    .btn-back {
        margin-left: var(--overlay-padding);
    }

    .btn-next {
        margin-right: var(--overlay-padding);
    }
</style>

@code {
    private int SvgNum { get; set; } = 0;
    private string SvgPath => $"/Images/map/map{SvgNum}.svg";
    private string ImageName { get; set; } = string.Empty;
    private string ImagePath { get; set; } = string.Empty;
    private DotNetObjectReference<Map>? ObjRef;
    private string? PreviousImage { get; set; } = string.Empty;
    private string? NextImage { get; set; } = string.Empty;

    private string? LastSelectedLabel { get; set; }

    [JSInvokable]
    public async Task OnSvgCircleClicked(string path)
    {
        if (!string.IsNullOrEmpty(LastSelectedLabel))
        {
            await JS.InvokeVoidAsync("setSvgCircleColor", LastSelectedLabel, "red");
        }

        ImageName = path;
        ImagePath = $"images/map/spheres/{path}";
        PreviousImage = GetRelativeImage(-1);
        NextImage = GetRelativeImage(1);
        LastSelectedLabel = path;

        StateHasChanged();

        await JS.InvokeVoidAsync("setSvgCircleColor", path, "gold");
    }

    private async Task FloorSelected(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int num))
        {
            SvgNum = num;
            await InvokeAsync(StateHasChanged);
            await JS.InvokeVoidAsync("attachSvgClickHandlers", ObjRef);
        }
    }


    private string? GetRelativeImage(int offset)
    {
        var currentName = Path.GetFileNameWithoutExtension(ImageName);
        if (int.TryParse(currentName, out int currentNumber))
        {
            int target = currentNumber + offset;
            if (target >= 1 && target <= 12)
                return $"{target}.jpg";

            return null;
        }
        return null;
    }




    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            ObjRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("attachSvgClickHandlers", ObjRef);
        }
    }

    public async Task SwitchDialog(bool right)
    {
        var current = Path.GetFileNameWithoutExtension(ImageName);
        if (!int.TryParse(current, out int currentNumber)) return;

        int target = currentNumber + (right ? 1 : -1);

        string? nextImage = null;

        if (target == 9 && SvgNum == 0)
        {
            SvgNum = 1;
            nextImage = "9.jpg";
        }
        else if (target == 8 && SvgNum == 1)
        {
            SvgNum = 0;
            nextImage = "8.jpg";
        }
        else
        {
            nextImage = GetRelativeImage(right ? 1 : -1);
        }

        if (nextImage is not null)
        {
            await InvokeAsync(StateHasChanged); // Renderuj nowy <object>

            // Poczekaj aż SVG się fizycznie załaduje
            await JS.InvokeVoidAsync("waitForSvgLoad");

            // Podłącz klikacze
            await JS.InvokeVoidAsync("attachSvgClickHandlers", ObjRef);

            // Zaznacz circle i otwórz dialog
            await OnSvgCircleClicked(nextImage);
        }
    }


    private Task CloseDialog()
    {
        ImagePath = string.Empty;
        return Task.CompletedTask;
    }
}

<script>
        window.attachSvgClickHandlers = (dotnetHelper) => {
        const obj = document.getElementById("svgObject");
        if (!obj) return;

        obj.addEventListener("load", () => {
            const svgDoc = obj.contentDocument;
            if (!svgDoc) {
                console.warn("Nie można odczytać dokumentu SVG.");
                return;
            }

            const elements = svgDoc.querySelectorAll("circle");

            elements.forEach(el => {
                el.style.cursor = "pointer";

                el.addEventListener("click", () => {
                    const label = el.getAttribute("inkscape:label");
                    if (!label) return;

                    dotnetHelper.invokeMethodAsync("OnSvgCircleClicked", label);
                });
            });
        });
    };

    window.setSvgCircleColor = (circleId, color) => {
        const obj = document.getElementById("svgObject");
        if (!obj || !obj.contentDocument) return;

        const elements = obj.contentDocument.querySelectorAll("circle");
        elements.forEach(el => {
            if (el.getAttribute("inkscape:label") === circleId) {
                el.style.fill = color;
            }
        });
    };

        window.waitForSvgLoad = () => {
        return new Promise((resolve, reject) => {
            const obj = document.getElementById("svgObject");
            if (!obj) return reject("Brak svgObject");

            if (obj.contentDocument?.readyState === "complete") {
                resolve();
                return;
            }

            obj.addEventListener("load", () => resolve(), { once: true });
        });
    };

</script>